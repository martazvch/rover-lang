enum Marker {
    circle,
    cross,
    none,

    fn toStr(self) -> str {
        return match self {
            .circle => "o"
            .cross => "x"
            .none => " "
        }
    }
}

struct Cell {
    marker: Marker = .none,

    fn mark(self, marker: Marker) {
        if self.marker != .none do print "Already played cell"

        self.marker = marker
    }

    fn toStr(self) -> str {
        return "[" + self.marker.toStr() + "]"
    }
}

struct Grid {
    cells: [][]Cell,
    dim: int,

    fn init(dim=3) -> Self {
        return Self{
            cells=[
                [Cell{}, Cell{}, Cell{}],
                [Cell{}, Cell{}, Cell{}],
                [Cell{}, Cell{}, Cell{}],
            ],
            dim,
        }
    }

    fn playAt(self, x, y: int, marker: Marker, method = false) {
        if self.cells[x][y].marker != .none {
            print "Already played in this cell"
            return
        }
        
        if method {
            self.cells[x][y].mark(marker)
        } else {
            self.cells[x][y] = Cell{marker}
        }
    }

    fn display(self) {
        var grid = "\n"
        var i = 0

        while i < self.dim {
            var line = ""
            var j = 0
            
            while j < self.dim {
                line += self.cells[i][j].toStr() + if j < 2 do " " else ""
                j += 1
            }

            i += 1
            grid += line + if i < self.dim do "\n" else ""
        }
        
        print grid
    }
}

fn main() {
    var grid = Grid.init()
    
    grid.display()
    grid.playAt(1, 2, .circle)
    grid.display()

    grid.playAt(1, 2, .circle)
    grid.playAt(2, 0, .cross)
    grid.display()

    grid.playAt(1, 0, .circle, true)
    grid.display()

    grid.playAt(1, 1, .cross, method=true)
    grid.display()
}


