struct Point {
    x, y: int
}

struct Poly {
    pt: Point,

    fn clone(self) -> Self {
        Poly{pt=Point{x=1, y=2}}
    }
}

struct Structure {
    poly: Poly,
    polys: []Poly,
}

fn main() {
    var pt = Point{x=2, y=6}
    var poly = Poly{pt}
    var structure = Structure{poly, polys=[poly]}

    var ref = pt
    var ref1 = structure.poly
    var ref2 = structure.poly.pt
    var ref3 = structure.polys
    var ref4 = structure.polys[0]
    var ref5 = structure.polys[0].pt

    var pts = [pt]
    var structs = [structure.poly.pt]

    // Functions arguments can't be mutated if they aren't references
    // so no need to increment a reference count they won't be written
    testFn(pt, structure.poly, structure)

    // Same rule but nested
    noRef2 = (structure.poly.clone().pt)
    noRef2 = { structure.poly.clone().pt } 
    noRef2 = ( { ( structure.poly.clone().pt ) } ) 

    noRef2 = if true do return else poly.clone().pt
    noRef2 = if true do poly.clone().pt else return
}

