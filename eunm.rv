enum Foo { a, b } // No payload

let foo = Foo.a // explicit
let foo: Foo = .a // inferred

enum Foo {
    a: int, // syntax 1 close to all other <value>: <type> syntax
    b(int), // syntax 2 close to instantation syntax
}

let foo = Foo.a(1) // other ideas?
let foo: Foo = .b(5)

enum Foo {
    a: [int],
    b: [int: str],
    c: struct {
        a, b: int
    }
}

// Sugar for array instancation?
let foo = Foo.a[1, 2, 3] // like this
let foo = Foo.a([1, 2, 3]) // or this

// Sugar for map instancation?
let foo = Foo.b[1: "oui", 2: "non"] // like this
let foo = Foo.b([1: "oui", 2: "non"]) // or this

// Sugar for struct instancation?
let foo = Foo.c{a=1, b=2} // like this
let foo = Foo.c({a=1, b=2}) // or this (it's laso syntax for block...)

// Pattern match on them
when foo {
    a => ... // just the tag name? Is there some edge cases where it is problematic?
    .a => ... // or classic dot
    c{a=1, b=2} => ... // destructure like this
    c({a=1, b=2}) => ... // destructure with parenthesis
}


enum Foo {
    a(int),
    b{a,b: int}
}

/////////
// Final:
enum Foo {
    a, // unit
    b: int, // scalar payload
    c: (x: int, y: int), // named tuple payload
    e: [int], // array payload
    f: struct { x: int, fn add() {...} }, // struct payload

    fn method() {}
}
// Instaciation
Foo.a // unit
Foo.b(10) // scalar
Foo.c((x=1, y=2)) // named tuple
Foo.e([1, 2, 3]) // array payload
Foo.f(.{x=1, y=2}) // anonymus structures?

var foo = Foo.a
foo.b // direct access that could result in a runtime error? Otherwise an int here
if foo = .b {} // test the tag, extracts nothing but useful for enums without payload
if foo = Foo.b {} // test the tag, extracts nothing but useful for enums without payload

// To extract stuff
match foo {
    .a => ..,
    .b => ..,
}
