struct Point {
    x, y: int

    fn display(self) {
        print "Point"
        print self.x
        print self.y
        print ""
    }
}

fn main() {
    var pt = Point{x=2, y=6}
    var pts = [pt]

    print "----------------------"
    pt.display()
    pts[0].display()
    print "----------------------\n"
    
    pt.x = 99
    pt.display()
    pts[0].display()

    //                No cow, only access
    //                GET_FIELD_REG, GET_FIELD
    //                     |
    foo.bar.baz   =   toto.titi.tata
    //   |
    // GET_FIELD_REG_COW, ASSIGN_REG_COW
    // Cow each step because it could be ref count

    //                No cow, only access
    //                     |
    foo.bar.baz   =   toto.titi[1].tata
    //   |
    // Cow each step because it could be ref count

    //                Cow the index call
    //                     |
    foo.bar.baz   =   toto.titi[toto.getIdx()].tata
    //   |
    // Cow each step because it could be ref count

    //  No cow
    //    |
    foo = bar
    // cow lhs -> SET_LOCAL_COW
    
    
}


// Rules
// - Each invoke triggers a cow
//      - Latter, check if function mutates the instance and emit only when needed
// - In assignment, trigger a cow for every thing as it could be referenced and modifying
//   the end of field chain modify all references to upper level in chain
//      - Cow for last element of chain is not necessary if it's not a heap object
// - In RHS, trigger a cow only if there is an invoke in the chain, otherwise it's only access
// - Simple assignment triggers ow if variable is a heap object, for locals and globals
//      - What happens if the variable isn't init? The cow looks for r1.obj
