const Writer = @import("std").Io.Writer;

pub const ParserMsg = union(enum) {
    chaining_cmp_op,
    default_value_self,
    expect_brace_after_struct_body,
    expect_brace_after_struct_lit,
    expect_brace_after_while_cond,
    expect_arrow_before_fn_type,
    expect_arrow_before_pm_arm_body,
    expect_brace_before_fn_body,
    expect_brace_before_struct_body,
    expect_brace_before_when_body,
    expect_block_or_do: struct { what: []const u8 },
    expect_closing_pipe,
    expect_colon_before_type,
    expect_comma_array_values,
    expect_equal_struct_lit,
    expect_expr: struct { found: []const u8 },
    expect_field_name,
    expect_field_type_or_default,
    expect_fn_name,
    expect_fn_in_struct_body,
    expect_name: struct { kind: []const u8 },
    expect_name_after_dot,
    expect_name_after_extract,
    expect_new_line,
    expect_new_line_pm_arm,
    expect_paren_after_fn_args,
    expect_paren_after_fn_name,
    expect_paren_after_fn_params,
    expect_struct_name,
    expect_type_name,
    expect_type_or_value_in_decl,
    import_alias_with_items,
    invalid_discard,
    invalid_extract_ctx,
    invalid_struct_literal,
    missing_array_close_bracket,
    missing_array_access_close_bracket,
    missing_brace_items_import,
    missing_brace_after_label,
    missing_bracket_array_type,
    missing_comma_after_field,
    missing_fn_param_type,
    non_ident_in_type,
    non_ident_alias,
    non_ident_label,
    positional_after_default_param,
    self_as_non_first_param,
    struct_lit_non_ident_field,
    too_many_fn_args: struct { what: []const u8 },
    typed_self,
    unclosed_brace,
    unclosed_paren,
    wrong_value_count_var_decl: struct { expect: usize },

    const Self = @This();

    pub fn getMsg(self: Self, writer: *Writer) !void {
        try switch (self) {
            .chaining_cmp_op => writer.writeAll("chaining comparison operators"),
            .default_value_self => writer.writeAll("can't assign a default value to 'self'"),
            .expect_arrow_before_fn_type => writer.writeAll("expect arrow '->' before function type"),
            .expect_arrow_before_pm_arm_body => writer.writeAll("expect arrow '=>' before pattern matching arm's body"),
            .expect_block_or_do => |e| writer.print("expect a block or 'do' after '{s}' condition", .{e.what}),
            .expect_brace_after_struct_body => writer.writeAll("expect opening brace after structure's body"),
            .expect_brace_after_struct_lit => writer.writeAll("expect opening brace after structure's name in structure initialization"),
            .expect_brace_after_while_cond => writer.writeAll("expect opening brace after 'while' condition"),
            .expect_brace_before_fn_body => writer.writeAll("expect opening brace before function's body"),
            .expect_brace_before_struct_body => writer.writeAll("expect opening brace before structure's body"),
            .expect_brace_before_when_body => writer.writeAll("expect opening brace before when's body"),
            .expect_closing_pipe => writer.writeAll("expect closing '|' after closure's parameters list"),
            .expect_colon_before_type => writer.writeAll("invalid variable type declaration"),
            .expect_comma_array_values => writer.writeAll("expect a ',' between array values"),
            .expect_equal_struct_lit => writer.writeAll("expect either '=' or '}' in structure literal field value"),
            .expect_expr => |e| writer.print("expected expression, found \"{s}\"", .{e.found}),
            .expect_field_name => writer.writeAll("expect structure field name"),
            .expect_field_type_or_default => writer.writeAll("structure fileds must be typed or have a default value"),
            .expect_fn_name => writer.writeAll("expect function name after 'fn' keyword"),
            .expect_fn_in_struct_body => writer.writeAll("expect functions declaration or nothing after structure's fields"),
            .expect_name => |e| writer.print("expect {s} name ", .{e.kind}),
            .expect_name_after_dot => writer.writeAll("expect field name after dot"),
            .expect_name_after_extract => writer.writeAll("expect binding name after extract operator '::'"),
            .expect_new_line => writer.writeAll("expect new line after statement"),
            .expect_new_line_pm_arm => writer.writeAll("expect new line after each arm of pattern matching"),
            .expect_paren_after_fn_args => writer.writeAll("expect closing parenthesis ')' after function's arguments"),
            .expect_paren_after_fn_name => writer.writeAll("expect opening parenthesis '(' after function's name"),
            .expect_paren_after_fn_params => writer.writeAll("expect closing parenthesis ')' after function's parameters"),
            .expect_struct_name => writer.writeAll("expect structure name"),
            .expect_type_name => writer.writeAll("expect type name"),
            .expect_type_or_value_in_decl => writer.writeAll("expect either a value or a type in varibale declaration"),
            .import_alias_with_items => writer.writeAll("can't use a module alias when importing specific items"),
            .invalid_discard => writer.writeAll("invalid discard expression"),
            .invalid_extract_ctx => writer.writeAll("extract operator '::' can't be used in this context"),
            .invalid_struct_literal => writer.writeAll("structure literal can only be used on literals and members"),
            .missing_array_close_bracket => writer.writeAll("missing ']' to end array values"),
            .missing_array_access_close_bracket => writer.writeAll("missing ']' to end array indexing"),
            .missing_brace_items_import => writer.writeAll("missing '}' to end specific items imports"),
            .missing_brace_after_label => writer.writeAll("missing '{' after block's label"),
            .missing_bracket_array_type => writer.writeAll("missing ']' in array type"),
            .missing_comma_after_field => writer.writeAll("comma might be missing between fields"),
            .missing_fn_param_type => writer.writeAll("missing function's parameter's type"),
            .non_ident_in_type => writer.writeAll("non-identifier in type name"),
            .non_ident_alias => writer.writeAll("alias must be an identifier"),
            .non_ident_label => writer.writeAll("labels of blocks must be identifiers"),
            .positional_after_default_param => writer.writeAll("non default parameter after default ones"),
            .self_as_non_first_param => writer.writeAll("'self' parameter not in first position"),
            .struct_lit_non_ident_field => writer.writeAll("trying to assign to a non-field in structure literal"),
            .too_many_fn_args => |e| writer.print("functions can't have more than 255 {s}", .{e.what}),
            .typed_self => writer.writeAll("can't specify a type for 'self', it's a keyword whose type is known by the compiler"),
            .unclosed_brace => writer.writeAll("unclosed brace"),
            .unclosed_paren => writer.writeAll("unclosed parenthesis"),
            .wrong_value_count_var_decl => |e| writer.print(
                "value count mismatch variable count, expect {} values",
                .{e.expect},
            ),
        };
    }

    pub fn getHint(self: Self, writer: *Writer) !void {
        try switch (self) {
            .chaining_cmp_op => writer.writeAll("this one is not allowed"),
            .expect_brace_after_struct_body,
            .expect_brace_after_struct_lit,
            .expect_brace_after_while_cond,
            .expect_arrow_before_fn_type,
            .expect_arrow_before_pm_arm_body,
            .expect_brace_before_fn_body,
            .expect_brace_before_when_body,
            .expect_brace_before_struct_body,
            .expect_block_or_do,
            .expect_closing_pipe,
            .expect_comma_array_values,
            .expect_name_after_dot,
            .expect_name_after_extract,
            .expect_paren_after_fn_args,
            .expect_paren_after_fn_name,
            .expect_paren_after_fn_params,
            .expect_struct_name,
            .missing_array_close_bracket,
            .missing_array_access_close_bracket,
            .missing_brace_items_import,
            .missing_brace_after_label,
            .missing_bracket_array_type,
            .missing_comma_after_field,
            .missing_fn_param_type,
            => writer.writeAll("expect to be here"),
            .expect_colon_before_type => writer.writeAll("before this identifier"),
            .expect_equal_struct_lit => writer.writeAll("expect to be after this"),
            .expect_field_name => writer.writeAll("this is not an identifier"),
            .expect_field_type_or_default => writer.writeAll("this field has no type and not default value"),
            .expect_fn_in_struct_body => writer.writeAll("this is unexpected"),
            .default_value_self,
            .expect_expr,
            .expect_new_line,
            .expect_new_line_pm_arm,
            .self_as_non_first_param,
            => writer.writeAll("here"),
            .expect_fn_name, .expect_type_name, .expect_name => writer.writeAll("this is not an identifier"),
            .expect_type_or_value_in_decl => writer.writeAll("this variable has no type and no value"),
            .import_alias_with_items => writer.writeAll("this alias is invalid"),
            .invalid_discard => writer.writeAll("expect an assignment to '_'"),
            .invalid_extract_ctx => writer.writeAll("this one"),
            .invalid_struct_literal => writer.writeAll("this syntaxe is invalid"),
            .non_ident_in_type, .non_ident_alias, .non_ident_label => writer.writeAll("this is not an identifier"),
            .positional_after_default_param => writer.writeAll("this parameter"),
            .struct_lit_non_ident_field => writer.writeAll("this field"),
            .typed_self => writer.writeAll("this type"),
            .too_many_fn_args => |e| writer.print("this is the 256th {s}", .{e.what}),
            .unclosed_brace => writer.writeAll("this opening brace"),
            .unclosed_paren => writer.writeAll("this opening parenthesis"),
            .wrong_value_count_var_decl => writer.writeAll("from this variable"),
        };
    }

    pub fn getHelp(self: Self, writer: *Writer) !void {
        try switch (self) {
            .chaining_cmp_op => writer.writeAll("split your comparison with 'and' and 'or' operators"),
            .default_value_self => writer.writeAll(
                "'self' is the only parameter than can't have a default value, as it's value is infered by the compiler",
            ),
            .expect_arrow_before_fn_type => writer.writeAll("add an arrow '->' between function's arguments list and type"),
            .expect_arrow_before_pm_arm_body => writer.writeAll(
                "Syntax is: <pattern> => <body> with optional binding like <pattern> :: binding => <body>",
            ),
            .expect_brace_before_fn_body,
            .expect_brace_before_struct_body,
            .expect_brace_before_when_body,
            => writer.writeAll("add an opening brace '{'"),
            .expect_brace_after_struct_body => writer.writeAll("add an closing brace '}'"),
            .expect_brace_after_struct_lit => writer.writeAll("add an openning brace '{'"),
            .expect_block_or_do => writer.writeAll("open a block (labelled or not) with ':label {' or use 'do' keyword before statement"),
            .expect_closing_pipe => writer.writeAll("add a closing '|' to end closure's parameters list"),
            .expect_colon_before_type => writer.writeAll("add ':' bofre type name"),
            .expect_comma_array_values => writer.writeAll(
                "values must be separated with commas in array declaration. Maybe you just forgot to close the declaration with ']'?",
            ),
            .expect_equal_struct_lit => writer.writeAll("syntax is either: Foo{ x = value } or Foo{ x } (if a variable 'x' is in scope)"),
            .expect_paren_after_fn_args => writer.writeAll("add an closing parenthesis ')' after function call"),
            .expect_paren_after_fn_name => writer.writeAll("add an opening parenthesis '(' between function's name and arguments list"),
            .expect_paren_after_fn_params => writer.writeAll("add an closing parenthesis ')' between function's parameters and return type"),
            .expect_field_name => writer.writeAll("structures fields must be declared before constants and methods"),
            .expect_field_type_or_default => writer.writeAll("add a type to the field like: 'field: type' or add a default value like: 'field = value'"),
            .expect_fn_in_struct_body => writer.writeAll("structures must declare their fields first followed by their methods, nothing more"),
            .expect_fn_name, .expect_type_name, .expect_name, .expect_struct_name => writer.writeAll("define an identifier"),
            .expect_type_or_value_in_decl => writer.writeAll("provide either a default value so that the compiler can infer the type or a type"),
            .expect_name_after_dot => writer.writeAll("field access syntax is: 'Structure.field'"),
            .expect_name_after_extract => writer.writeAll("extract operator syntax is: <expression> :: <name>'"),
            .expect_new_line_pm_arm => writer.writeAll("each arm of pattern matching construct (match and when) have to be on their own line"),
            .import_alias_with_items => writer.writeAll(
                "you can either alias the whole module without importing specific items or alias each specific items",
            ),
            .invalid_discard => writer.writeAll("add '=' token: _ = call()"),
            .invalid_extract_ctx => writer.writeAll("can only be used in 'if' conditions, pattern matching branch or for loops"),
            .invalid_struct_literal => writer.writeAll("structure literals can only be acheived on types"),
            .missing_array_close_bracket => writer.writeAll("syntaxe to decalre array is: 'var array = [<value>, <value>, ...]'"),
            .missing_array_access_close_bracket => writer.writeAll("syntaxe to index array is: 'array[<index>]'"),
            .missing_brace_items_import => writer.writeAll("syntaxe to import specific items from module is: use foo{ item1, ... }"),
            .missing_brace_after_label => writer.writeAll("syntaxe to to declare a labelled lock is ':<label> {}'"),
            .missing_bracket_array_type => writer.writeAll("syntaxe to define array type is: '[]<type-name>'"),
            .missing_comma_after_field => writer.writeAll("structure fields have ot be separated by commas"),
            .missing_fn_param_type => writer.writeAll("function's paramters' types are mandatory, add it after ':'"),
            .non_ident_in_type => writer.writeAll("type names must be either one identifier or multiple ones separated with '.'"),
            .non_ident_alias => writer.writeAll("change alias name to a valid identifier"),
            .non_ident_label => writer.writeAll("change block's label to an identifier like ':b {}'"),
            .positional_after_default_param => writer.writeAll("positional parameters must be declared before default value ones"),
            .self_as_non_first_param => writer.writeAll("'self' parameter must always be in first place. Change function's declaration"),
            .struct_lit_non_ident_field => writer.writeAll("structure literal must define a value for all fields that doesn't have a default one"),
            .too_many_fn_args => |e| writer.print(
                "split your function into multiple small ones or pass your {s} in structures / arrays",
                .{e.what},
            ),
            .typed_self => writer.writeAll("remove the type, the compiler infers the type for 'self' on its own"),
            .unclosed_brace => writer.writeAll("close the opening brace"),
            .unclosed_paren => writer.writeAll("close the opening parenthesis"),
            .wrong_value_count_var_decl => writer.writeAll(
                "you must either provide no value, 1 value that will assigned to each variable or one per variable",
            ),
            else => {},
        };
    }
};
